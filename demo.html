<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>事件系统 - 本地坐标</title>
  <style>
    canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <canvas id="myCanvas" width="500" height="500"></canvas>
  <script>
    // 通用事件对象
    class Event {
      constructor(type, target, data) {
        this.type = type;
        this.target = target;
        this.data = data; // 包含全局坐标和本地坐标
        this.cancelBubble = false;
      }

      stopPropagation() {
        this.cancelBubble = true;
      }
    }

    // 事件管理器
    class EventManager {
      constructor() {
        this.listeners = new Map();
      }

      addEventListener(node, type, callback) {
        if (!this.listeners.has(node)) {
          this.listeners.set(node, {});
        }
        if (!this.listeners.get(node)[type]) {
          this.listeners.get(node)[type] = [];
        }
        this.listeners.get(node)[type].push(callback);
      }

      dispatchEvent(event) {
        let currentNode = event.target;
        while (currentNode && !event.cancelBubble) {
          const listeners = this.listeners.get(currentNode)?.[event.type];
          if (listeners) {
            for (const callback of listeners) {
              callback(event);
              if (event.cancelBubble) break;
            }
          }
          currentNode = currentNode.parent;
        }
      }
    }

    const globalEventManager = new EventManager();

    // 抽象节点
    class Node {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        this.scaleX = 1; // 水平缩放
        this.scaleY = 1; // 垂直缩放
        this.rotation = 0; // 旋转角度（弧度）

        this.parent = null;
        this.children = [];
      }

      addChild(child) {
        child.parent = this;
        this.children.push(child);
      }

      on(type, callback) {
        globalEventManager.addEventListener(this, type, callback);
      }

      trigger(type, data) {
        const event = new Event(type, this, data);
        globalEventManager.dispatchEvent(event);
      }

      // 获取全局变换矩阵
      getGlobalTransform() {
        let node = this;
        let transform = this.getLocalTransform();
        while (node.parent) {
          node = node.parent;
          transform = this.multiplyMatrices(node.getLocalTransform(), transform);
        }
        return transform;
      }

      // 获取本地变换矩阵
      getLocalTransform() {
        const cos = Math.cos(this.rotation);
        const sin = Math.sin(this.rotation);
        return [
          [this.scaleX * cos, -this.scaleY * sin, this.x],
          [this.scaleX * sin, this.scaleY * cos, this.y],
          [0, 0, 1],
        ];
      }

      // 逆变换矩阵
      getInverseTransform(matrix) {
        const a = matrix[0][0], b = matrix[0][1], c = matrix[1][0], d = matrix[1][1];
        const tx = matrix[0][2], ty = matrix[1][2];
        const det = a * d - b * c;
        return [
          [d / det, -b / det, (b * ty - d * tx) / det],
          [-c / det, a / det, (c * tx - a * ty) / det],
          [0, 0, 1],
        ];
      }

      // 矩阵相乘
      multiplyMatrices(a, b) {
        const result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            result[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
          }
        }
        return result;
      }

      // 应用矩阵变换
      applyMatrix(matrix, point) {
        return [
          matrix[0][0] * point[0] + matrix[0][1] * point[1] + matrix[0][2] * point[2],
          matrix[1][0] * point[0] + matrix[1][1] * point[1] + matrix[1][2] * point[2],
          matrix[2][0] * point[0] + matrix[2][1] * point[1] + matrix[2][2] * point[2],
        ];
      }

      // 碰撞检测（点击点是否在节点范围内）
      contains(x, y) {
        const globalTransform = this.getGlobalTransform();
        const inverseTransform = this.getInverseTransform(globalTransform);
        const localPoint = this.applyMatrix(inverseTransform, [x, y, 1]);
        return (
          localPoint[0] >= 0 &&
          localPoint[0] <= this.width &&
          localPoint[1] >= 0 &&
          localPoint[1] <= this.height
        );
      }

      // 获取本地坐标
      getLocalPoint(globalX, globalY) {
        const globalTransform = this.getGlobalTransform();
        const inverseTransform = this.getInverseTransform(globalTransform);
        const localPoint = this.applyMatrix(inverseTransform, [globalX, globalY, 1]);
        return { x: localPoint[0], y: localPoint[1] };
      }
    }

    // Canvas 适配器
    class CanvasAdapter {
      constructor(canvas, rootNode) {
        this.canvas = canvas;
        this.rootNode = rootNode;

        this.canvas.addEventListener('click', (e) => this.handleEvent(e));
      }

      handleEvent(e) {
        const { offsetX, offsetY } = e;
        const targetNode = this.hitTest(offsetX, offsetY);
        if (targetNode) {
          const localPoint = targetNode.getLocalPoint(offsetX, offsetY);
          targetNode.trigger('click', {
            global: { x: offsetX, y: offsetY },
            local: localPoint,
          });
        }
      }

      hitTest(x, y) {
        const findHitNode = (node) => {
          for (const child of node.children) {
            if (child.contains(x, y)) {
              return findHitNode(child) || child;
            }
          }
          return null;
        };
        return findHitNode(this.rootNode);
      }
    }

    // 示例
    const rootNode = new Node(0, 0, 500, 500);
    const rect = new Node(100, 100, 100, 100);
    rect.scaleX = 2;
    rect.scaleY = 2;
    rect.on('click', (event) => {
      console.log('Rect clicked!');
      console.log('Global coordinates:', event.data.global);
      console.log('Local coordinates:', event.data.local);
    });
    rootNode.addChild(rect);

    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const canvasAdapter = new CanvasAdapter(canvas, rootNode);

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(rect.x, rect.y);
      ctx.scale(rect.scaleX, rect.scaleY);
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, rect.width, rect.height);
      ctx.restore();
    }

    render();
  </script>
</body>

</html>