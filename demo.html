<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>äº‹ä»¶ç³»ç»Ÿ - æ”¯æŒæ—‹è½¬</title>
  <script src="https://cdn.jsdelivr.net/npm/konva@8.4.2/konva.min.js"></script>
  <style>
    #container {
      border: 1px solid black;
      width: 800px;
      height: 600px;
    }

    #controls {
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <div id="controls">
    <button onclick="rotateRect()">æ—‹è½¬çŸ©å½¢</button>
    <span id="rotationDisplay">å½“å‰æ—‹è½¬: 0Â°</span>
  </div>
  <div id="container"></div>
  <script>
    // é€šç”¨äº‹ä»¶å¯¹è±¡
    class Event {
      constructor(type, target, data) {
        this.type = type;
        this.target = target;
        this.data = data;
        this.cancelBubble = false;
      }

      stopPropagation() {
        this.cancelBubble = true;
      }
    }

    // äº‹ä»¶ç®¡ç†å™¨
    class EventManager {
      constructor() {
        this.listeners = new Map();
      }

      addEventListener(node, type, callback) {
        if (!this.listeners.has(node)) {
          this.listeners.set(node, {});
        }
        if (!this.listeners.get(node)[type]) {
          this.listeners.get(node)[type] = [];
        }
        this.listeners.get(node)[type].push(callback);
      }

      dispatchEvent(event) {
        let currentNode = event.target;
        while (currentNode && !event.cancelBubble) {
          const listeners = this.listeners.get(currentNode)?.[event.type];
          if (listeners) {
            for (const callback of listeners) {
              callback(event);
              if (event.cancelBubble) break;
            }
          }
          currentNode = currentNode.parent;
        }
      }
    }

    const globalEventManager = new EventManager();

    // æŠ½è±¡èŠ‚ç‚¹
    class Node {
      constructor(x, y, width, height) {
        this.x = x;           // å·¦ä¸Šè§’åæ ‡
        this.y = y;
        this.width = width;
        this.height = height;

        this.scaleX = 1;
        this.scaleY = 1;
        this.rotation = 0;    // åº¦æ•°ï¼Œé¡ºæ—¶é’ˆ

        this.parent = null;
        this.children = [];
      }

      addChild(child) {
        child.parent = this;
        this.children.push(child);
      }

      on(type, callback) {
        globalEventManager.addEventListener(this, type, callback);
      }

      trigger(type, data) {
        const event = new Event(type, this, data);
        globalEventManager.dispatchEvent(event);
      }

      // è·å–çŸ©å½¢çš„å‡ ä½•ä¸­å¿ƒç‚¹
      getCenterX() {
        return this.x + this.width / 2;
      }

      getCenterY() {
        return this.y + this.height / 2;
      }

      // ä¿®æ­£çš„ç¢°æ’æ£€æµ‹
      contains(canvasX, canvasY) {
        // æ­¥éª¤1ï¼šè€ƒè™‘çˆ¶èŠ‚ç‚¹çš„ç¼©æ”¾ï¼ˆæ ¹èŠ‚ç‚¹ç¼©æ”¾2å€ï¼‰
        let worldX = canvasX;
        let worldY = canvasY;

        if (this.parent && (this.parent.scaleX !== 1 || this.parent.scaleY !== 1)) {
          worldX = canvasX / this.parent.scaleX;
          worldY = canvasY / this.parent.scaleY;
        }

        // æ­¥éª¤2ï¼šè®¡ç®—ç›¸å¯¹äºçŸ©å½¢ä¸­å¿ƒçš„åæ ‡
        const centerX = this.getCenterX();
        const centerY = this.getCenterY();
        const dx = worldX - centerX;
        const dy = worldY - centerY;

        // æ­¥éª¤3ï¼šåº”ç”¨åå‘æ—‹è½¬å˜æ¢
        const radians = -this.rotation * Math.PI / 180; // è´Ÿå·ç”¨äºåå‘æ—‹è½¬
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        const rotatedX = dx * cos - dy * sin;
        const rotatedY = dx * sin + dy * cos;

        // æ­¥éª¤4ï¼šè½¬æ¢ä¸ºæœ¬åœ°åæ ‡ï¼ˆç›¸å¯¹äºå·¦ä¸Šè§’ï¼‰
        const localX = rotatedX + this.width / 2;
        const localY = rotatedY + this.height / 2;

        // æ­¥éª¤5ï¼šæ£€æŸ¥æ˜¯å¦åœ¨çŸ©å½¢èŒƒå›´å†…
        const isInside = localX >= 0 && localX <= this.width &&
          localY >= 0 && localY <= this.height;

        console.log(`=== ç¢°æ’æ£€æµ‹ ===`);
        console.log(`Canvasç‚¹å‡»: (${canvasX}, ${canvasY})`);
        console.log(`ä¸–ç•Œåæ ‡: (${worldX}, ${worldY})`);
        console.log(`çŸ©å½¢ä¸­å¿ƒ: (${centerX}, ${centerY})`);
        console.log(`ç›¸å¯¹ä¸­å¿ƒ: (${dx}, ${dy})`);
        console.log(`æ—‹è½¬${this.rotation}Â°å: (${rotatedX.toFixed(2)}, ${rotatedY.toFixed(2)})`);
        console.log(`æœ¬åœ°åæ ‡: (${localX.toFixed(2)}, ${localY.toFixed(2)})`);
        console.log(`çŸ©å½¢èŒƒå›´: 0-${this.width} x 0-${this.height}`);
        console.log(`ç»“æœ: ${isInside ? 'å†…éƒ¨' : 'å¤–éƒ¨'}`);
        console.log('---');

        return isInside;
      }

      // è·å–å‡†ç¡®çš„æœ¬åœ°åæ ‡
      getLocalPoint(canvasX, canvasY) {
        // è€ƒè™‘çˆ¶èŠ‚ç‚¹ç¼©æ”¾
        let worldX = canvasX;
        let worldY = canvasY;

        if (this.parent && (this.parent.scaleX !== 1 || this.parent.scaleY !== 1)) {
          worldX = canvasX / this.parent.scaleX;
          worldY = canvasY / this.parent.scaleY;
        }

        const centerX = this.getCenterX();
        const centerY = this.getCenterY();
        const dx = worldX - centerX;
        const dy = worldY - centerY;

        const radians = -this.rotation * Math.PI / 180;
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        const rotatedX = dx * cos - dy * sin;
        const rotatedY = dx * sin + dy * cos;

        const localX = rotatedX + this.width / 2;
        const localY = rotatedY + this.height / 2;

        return { x: localX, y: localY };
      }
    }

    // åˆå§‹åŒ– Konva èˆå°
    const stage = new Konva.Stage({
      container: 'container',
      width: 800,
      height: 600,
    });
    stage.scale({ x: 2, y: 2 }); // æ•´ä¸ªèˆå°æ”¾å¤§2å€

    const layer = new Konva.Layer();
    stage.add(layer);

    // åˆ›å»ºæ ¹èŠ‚ç‚¹
    const rootNode = new Node(0, 0, 400, 300);
    rootNode.scaleX = 2;
    rootNode.scaleY = 2;

    // åˆ›å»ºçŸ©å½¢èŠ‚ç‚¹
    const rect = new Node(100, 100, 100, 100);
    rect.on('click', (event) => {
      console.log('âœ… çŸ©å½¢è¢«ç‚¹å‡»äº†!');
      console.log('å…¨å±€åæ ‡:', event.data.global);
      console.log('æœ¬åœ°åæ ‡:', event.data.local);
      rotateRect();
    });
    rootNode.addChild(rect);

    // ç”¨ Konva ç»˜åˆ¶çŸ©å½¢ï¼ˆæ³¨æ„ï¼šKonvaçš„åæ ‡è¦å’ŒNodeä¿æŒä¸€è‡´ï¼‰
    const konvaRect = new Konva.Rect({
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      fill: 'red',
      stroke: 'black',
      strokeWidth: 1,
      draggable: false,
      // è®¾ç½®æ—‹è½¬ä¸­å¿ƒä¸ºçŸ©å½¢ä¸­å¿ƒ
      offsetX: rect.width / 2,
      offsetY: rect.height / 2,
    });

    // å°† Konva çŸ©å½¢çš„ä½ç½®è®¾ç½®ä¸ºå‡ ä½•ä¸­å¿ƒ
    konvaRect.x(rect.getCenterX());
    konvaRect.y(rect.getCenterY());

    layer.add(konvaRect);

    // æ·»åŠ ä¸€ä¸ªå‚è€ƒç‚¹æ˜¾ç¤ºçŸ©å½¢ä¸­å¿ƒ
    const centerDot = new Konva.Circle({
      x: rect.getCenterX(),
      y: rect.getCenterY(),
      radius: 3,
      fill: 'blue'
    });
    layer.add(centerDot);

    // æ›´æ–°æ˜¾ç¤º
    function updateDisplay() {
      konvaRect.rotation(rect.rotation);
      document.getElementById('rotationDisplay').textContent = `å½“å‰æ—‹è½¬: ${rect.rotation}Â°`;
      layer.batchDraw();
    }

    // æ—‹è½¬çŸ©å½¢æŒ‰é’®
    function rotateRect() {
      rect.rotation = (rect.rotation + 15) % 360;
      updateDisplay();
    }

    // DOM å®¹å™¨äº‹ä»¶ç›‘å¬
    const container = document.getElementById('container');
    container.addEventListener('click', (e) => {
      const { offsetX, offsetY } = e;
      console.log(`\nğŸ–±ï¸ ç‚¹å‡»ç”»å¸ƒ: (${offsetX}, ${offsetY})`);

      // ç¢°æ’æ£€æµ‹
      const targetNode = rootNode.children.find((child) => child.contains(offsetX, offsetY));
      if (targetNode) {
        const localPoint = targetNode.getLocalPoint(offsetX, offsetY);
        targetNode.trigger('click', {
          global: { x: offsetX, y: offsetY },
          local: localPoint,
        });
      } else {
        console.log('âŒ æ²¡æœ‰ç‚¹å‡»åˆ°ä»»ä½•èŠ‚ç‚¹');
      }
    });

    // åˆå§‹æ¸²æŸ“
    updateDisplay();
  </script>
</body>

</html>