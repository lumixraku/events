<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>事件系统 - 使用矩阵</title>
  <script src="https://cdn.jsdelivr.net/npm/konva@8.4.2/konva.min.js"></script>
  <style>
    #container {
      border: 1px solid black;
      width: 800px;
      height: 600px;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <script>
    // 通用事件对象
    class Event {
      constructor(type, target, data) {
        this.type = type;
        this.target = target;
        this.data = data;
        this.cancelBubble = false;
      }

      stopPropagation() {
        this.cancelBubble = true;
      }
    }

    // 事件管理器
    class EventManager {
      constructor() {
        this.listeners = new Map();
      }

      addEventListener(node, type, callback) {
        if (!this.listeners.has(node)) {
          this.listeners.set(node, {});
        }
        if (!this.listeners.get(node)[type]) {
          this.listeners.get(node)[type] = [];
        }
        this.listeners.get(node)[type].push(callback);
      }

      dispatchEvent(event) {
        let currentNode = event.target;
        while (currentNode && !event.cancelBubble) {
          const listeners = this.listeners.get(currentNode)?.[event.type];
          if (listeners) {
            for (const callback of listeners) {
              callback(event);
              if (event.cancelBubble) break;
            }
          }
          currentNode = currentNode.parent;
        }
      }
    }

    const globalEventManager = new EventManager();

    // 抽象节点
    class Node {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        this.scaleX = 1;
        this.scaleY = 1;
        this.rotation = 0;

        this.parent = null;
        this.children = [];
      }

      addChild(child) {
        child.parent = this;
        this.children.push(child);
      }

      on(type, callback) {
        globalEventManager.addEventListener(this, type, callback);
      }

      trigger(type, data) {
        const event = new Event(type, this, data);
        globalEventManager.dispatchEvent(event);
      }

      // 修正：获取节点的本地变换矩阵
      getLocalTransform() {
        const cos = Math.cos(this.rotation);
        const sin = Math.sin(this.rotation);

        // 正确的变换矩阵：先缩放，再旋转，最后平移
        return [
          [this.scaleX * cos, -this.scaleX * sin, this.x],
          [this.scaleY * sin, this.scaleY * cos, this.y],
          [0, 0, 1]
        ];
      }

      // 修正：获取全局变换矩阵
      getGlobalTransform() {
        const transforms = [];
        let node = this;

        // 收集从当前节点到根节点的所有变换
        while (node) {
          transforms.unshift(node.getLocalTransform());
          node = node.parent;
        }

        // 从根节点开始，依次应用变换
        let result = transforms[0];
        for (let i = 1; i < transforms.length; i++) {
          result = this.multiplyMatrices(result, transforms[i]);
        }

        return result;
      }

      // 修正：计算逆矩阵
      getInverseTransform(matrix) {
        const a = matrix[0][0], b = matrix[0][1], tx = matrix[0][2];
        const c = matrix[1][0], d = matrix[1][1], ty = matrix[1][2];

        const det = a * d - b * c;

        if (Math.abs(det) < 1e-10) {
          // 矩阵不可逆，返回单位矩阵
          return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
        }

        return [
          [d / det, -b / det, (b * ty - d * tx) / det],
          [-c / det, a / det, (c * tx - a * ty) / det],
          [0, 0, 1]
        ];
      }

      // 矩阵相乘
      multiplyMatrices(a, b) {
        const result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            result[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
          }
        }
        return result;
      }

      // 应用矩阵变换
      applyMatrix(matrix, point) {
        return [
          matrix[0][0] * point[0] + matrix[0][1] * point[1] + matrix[0][2],
          matrix[1][0] * point[0] + matrix[1][1] * point[1] + matrix[1][2],
          1
        ];
      }

      // 修正：碰撞检测
      contains(globalX, globalY) {
        const globalTransform = this.getGlobalTransform();
        const inverseTransform = this.getInverseTransform(globalTransform);
        const localPoint = this.applyMatrix(inverseTransform, [globalX, globalY]);

        console.log(`Node (${this.x}, ${this.y}, ${this.width}, ${this.height})`);
        console.log('Global point:', globalX, globalY);
        console.log('Local point:', localPoint[0], localPoint[1]);

        return (
          localPoint[0] >= 0 &&
          localPoint[0] <= this.width &&
          localPoint[1] >= 0 &&
          localPoint[1] <= this.height
        );
      }

      // 获取本地坐标
      getLocalPoint(globalX, globalY) {
        const globalTransform = this.getGlobalTransform();
        const inverseTransform = this.getInverseTransform(globalTransform);
        const localPoint = this.applyMatrix(inverseTransform, [globalX, globalY]);
        return { x: localPoint[0], y: localPoint[1] };
      }
    }

    // 初始化 Konva 舞台
    const stage = new Konva.Stage({
      container: 'container',
      width: 800,
      height: 600,
    });
    stage.scale({ x: 2, y: 2 });

    const layer = new Konva.Layer();
    stage.add(layer);

    // 修正：创建根节点
    const rootNode = new Node(0, 0, 400, 300); // 注意：根节点的逻辑尺寸应该是缩放后的尺寸
    rootNode.scaleX = 2;
    rootNode.scaleY = 2;

    // 创建矩形节点
    const rect = new Node(100, 100, 100, 100);
    rect.on('click', (event) => {
      console.log('Rect clicked!');
      console.log('Global coordinates:', event.data.global);
      console.log('Local coordinates:', event.data.local);
    });
    rootNode.addChild(rect);

    // 用 Konva 绘制矩形
    const konvaRect = new Konva.Rect({
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      fill: 'red',
      draggable: false,
    });

    layer.add(konvaRect);

    // DOM 容器事件监听
    const container = document.getElementById('container');
    container.addEventListener('click', (e) => {
      const { offsetX, offsetY } = e;
      console.log('Canvas click at:', offsetX, offsetY);

      // 碰撞检测 - 直接使用画布坐标
      const targetNode = rootNode.children.find((child) => child.contains(offsetX, offsetY));
      if (targetNode) {
        const localPoint = targetNode.getLocalPoint(offsetX, offsetY);
        targetNode.trigger('click', {
          global: { x: offsetX, y: offsetY },
          local: localPoint,
        });
      }
    });

    // 渲染
    layer.batchDraw();
  </script>
</body>

</html>